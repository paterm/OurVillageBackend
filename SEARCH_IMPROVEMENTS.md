# Улучшения поиска

## Текущая реализация

Сейчас используется поиск на основе ILIKE с приоритетами:
- Совпадения в заголовке имеют высший приоритет
- Совпадения в категории - средний приоритет  
- Совпадения в описании - низкий приоритет
- Сортировка по релевантности

## Проблемы текущего подхода

1. Находит нерелевантные результаты (например, "бытового" в описании при поиске "Бытовка")
2. Не учитывает морфологию русского языка полностью
3. Нет поддержки синонимов

## Рекомендуемые решения

### Вариант 1: PostgreSQL Full-Text Search (рекомендуется)

**Преимущества:**
- Встроен в PostgreSQL, не требует дополнительных сервисов
- Поддерживает русскую морфологию через расширение `pg_trgm`
- Хорошая производительность
- Проще в настройке чем ElasticSearch

**Недостатки:**
- Менее гибкий чем ElasticSearch
- Требует настройки индексов

**Реализация:**
1. Установить расширение `pg_trgm` для поддержки триграмм
2. Создать GIN индекс на tsvector колонке
3. Использовать функции `to_tsvector` и `to_tsquery` для поиска

### Вариант 2: ElasticSearch

**Преимущества:**
- Очень гибкий и мощный
- Отличная поддержка морфологии через анализаторы
- Поддержка синонимов, автодополнения
- Масштабируемость

**Недостатки:**
- Требует отдельный сервис
- Больше ресурсов
- Сложнее в настройке

**Когда использовать:**
- Если нужен очень сложный поиск
- Если планируется много поисковых запросов
- Если нужны функции автодополнения, поиска по геолокации и т.д.

### Вариант 3: Улучшенный текущий подход

Можно улучшить текущий поиск:
- Добавить минимальный порог релевантности
- Исключать результаты, где слово найдено только в описании (если не найдено в заголовке/категории)
- Использовать более умную логику для корней слов

## Рекомендация

Для начала использовать **PostgreSQL Full-Text Search** с расширением `pg_trgm`. Это даст хорошие результаты без усложнения архитектуры.

Если в будущем понадобятся более сложные функции (автодополнение, поиск по геолокации, сложная аналитика), можно мигрировать на ElasticSearch.

